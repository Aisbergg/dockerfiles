# container_managed=true                                                       #
#                                                                              #
# NOTE: by default this file is automatically generated on container startup.  #
# To disable the autogeneration simply change the first line of this file to   #
# 'container_managed=false'                                                    #
################################################################################

limit_conn_log_level    warn;
limit_req_zone          $limit zone=wdqs:{{ NGINX_REQ_LIMIT_ZONE_SIZE }} rate={{ NGINX_REQ_LIMIT_PER_IP_RATE }};

{% if NGINX_REDIRECT_TO_FIRST_DOMAIN and DOMAINNAMES|length > 1 -%}
server {
    listen                      8080;
    listen                      [::]:8080;
    {% if NGINX_TLS_ENABLED -%}
    listen                      8443 ssl{{ ' http2' if NGINX_HTTP_VERSION == "2.0" else '' }};
    listen                      [::]:8443 ssl{{ ' http2' if NGINX_HTTP_VERSION == "2.0" else '' }};
    {%- endif %}
    server_name                 {{ DOMAINNAMES[1:] | join(' ') }}

    location / {
        return 301              $real_scheme://{{ DOMAINNAMES[0] }}$request_uri;
    }
}
{%- endif %}

server {
    listen                      8080;
    listen                      [::]:8080;
    {% if NGINX_TLS_ENABLED -%}
    listen                      8443 ssl{{ ' http2' if NGINX_HTTP_VERSION == "2.0" else '' }};
    listen                      [::]:8443 ssl{{ ' http2' if NGINX_HTTP_VERSION == "2.0" else '' }};
    {%- endif %}
    {% if DOMAINNAMES|length > 0 -%}
    server_name                 {% if NGINX_REDIRECT_TO_FIRST_DOMAIN %}{{ DOMAINNAMES[0] }}{% else %}{{ DOMAINNAMES | join(' ') }}{% endif %};
    {%- endif %}

    root                        /container/www;
    index                       index.html;

    {% if NGINX_REWRITE_HTTPS -%}
    if ($real_scheme != "https") {
        return 301              https://$host$request_uri;
    }
    {%- endif %}
    {% set WDQS_FRONTEND_LOCATION_ROOT = WDQS_FRONTEND_LOCATION_ROOT.rstrip('/') -%}
    {% if WDQS_FRONTEND_LOCATION_ROOT | length > 0 -%}
    # add trailing slash, so that the browser will take care of resolving the correct asset paths
    rewrite ^{{ WDQS_FRONTEND_LOCATION_ROOT }}$ {{ WDQS_FRONTEND_LOCATION_ROOT }}/ permanent;
    # rewrite path internally to match file structure
    rewrite ^{{ WDQS_FRONTEND_LOCATION_ROOT }}/(.*)$ /$1 last;
    {%- endif %}

    # add nosniff header
    #   see: https://www.owasp.org/index.php/List_of_useful_HTTP_headers
    more_set_headers "X-Content-Type-Options: nosniff";

    # enable anti-cross-site scripting filter built into Internet Explorer,
    # Chrome and Safari
    #   see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
    more_set_headers "X-XSS-Protection: 1; mode=block";

    # limit requests per second per ip
    limit_req zone=wdqs burst={{ NGINX_REQ_LIMIT_PER_IP_BURST }} nodelay;

    {% if WDQS_FRONTEND_API_WIKIBASE_URI | length == 0 %}
    location ~ ^/proxy/wikibase/(.*)$ {
        proxy_buffering            off;
        proxy_read_timeout         300;
        proxy_set_header           Host                $http_host;
        proxy_set_header           X-Real-IP           $proxy_add_x_forwarded_for;
        proxy_set_header           X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header           X-Forwarded-Proto   $real_scheme;
        # strip 'Proxy' header (see httpoxy vulnerability)
        proxy_set_header           Proxy               "";
        proxy_http_version         1.1;  # recommended with keepalive connections

        resolver 127.0.0.11 valid=30s;
        set $wikibase_uri {{ WDQS_FRONTEND_API_WIKIBASE_URI.rstrip('/') }}/;
        proxy_pass $wikibase_uri/$1$is_args$args;
    }
    {% endif %}

    {% if WDQS_FRONTEND_API_SPARQL_URI | length == 0 -%}
    # regex is required here, because of the Nginx behavior, when using variables in `proxy_pass`
    location ~ ^/proxy/wdqs/(.*)$ {
        limit_except GET OPTIONS POST {
            deny all;
        }

        proxy_set_header X-BIGDATA-MAX-QUERY-MILLIS 60000;
        {% if WDQS_FRONTEND_READ_ONLY -%}
        proxy_set_header X-BIGDATA-READ-ONLY "yes";
        {%- endif %}

        more_set_headers "Access-Control-Allow-Origin: * always";
        more_set_headers "Vary: Accept";

        client_max_body_size       1m;
        client_body_buffer_size    1m;
        proxy_intercept_errors     off;
        proxy_buffering            on;
        proxy_buffer_size          16k;
        proxy_buffers              256 16k;
        proxy_busy_buffers_size    256k;
        proxy_temp_file_write_size 16k;
        proxy_max_temp_file_size   10m;
        proxy_read_timeout         300;
        proxy_set_header           Host                $http_host;
        proxy_set_header           X-Real-IP           $proxy_add_x_forwarded_for;
        proxy_set_header           X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header           X-Forwarded-Proto   $real_scheme;
        # strip 'Proxy' header (see httpoxy vulnerability)
        proxy_set_header           Proxy               "";
        proxy_http_version         1.1;  # recommended with keepalive connections

        resolver 127.0.0.11 valid=30s;
        # passing the host as a variable to `proxy_pass` stops Nginx from
        # checking the availbility of that host, so that Nginx can start without
        # the need of the backend host to be available
        set $wdqs_backend_uri {{ WDQS_FRONTEND_API_SPARQL_PROXY_URI.rstrip('/') }};
        proxy_pass $wdqs_backend_uri/$1$is_args$args;
    }
    {% endif %}

    location / {
        try_files $uri $uri/ /index.html;
    }

    location = /robots.txt  { log_not_found off; }
    location = /favicon.ico { access_log off; log_not_found off; }
    location ~ /\.          { access_log off; log_not_found off; deny all; }

    # client caching
    location ~* \.(?:css|js|jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ {
        expires                 1M;
        more_set_headers        "Cache-Control: public, must-revalidate, proxy-revalidate";
        access_log              off;
    }
}
